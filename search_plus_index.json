{"./":{"url":"./","title":"前言","keywords":"","body":"介绍 本项目致力于对 Python 3.7 的源码分析，深度参考陈儒大大的《Python 源码剖析》，编写 Python 3 的版本。 希望各位 Python 爱好者能参与其中，一起探索 Python 魔法背后的奥秘！ 使用 您可以直接访问 在线版，或者根据以下步骤访问本地版。 前置条件 您的系统上需要安装好 node。 使用 make 命令 若您可使用 make 命令，简单执行如下命令进行初始化： make init 执行如下命令运行服务端： make run 使用 gitbook 命令 若您不能使用 make 命令，或想直接使用 gitbook 命令，执行如下命令进行初始化： npm i -g gitbook-cli #可能需要sudo gitbook install 执行如下命令运行服务端： gitbook serve 访问 直接访问 http://localhost:4000 即可查看本书内容。 Roadmap 大体按照《Python 源码剖析》中的目录结构进行编写。依次介绍 Python 源码基本信息、内建对象和虚拟机。 [x] 章节 [x] 序章 [x] 前言 [x] Python 源代码的组织 [x] Windows 环境下编译 Python [x] UNIX/Linux 环境下编译 Python [x] 修改 Python 源码 [ ] Python 内建对象 [x] Python 对象初探 [ ] Python 整数对象 [ ] Python 字符串 对象 [ ] Python List 对象 [x] Python Dict 对象 [ ] Python Set 对象 [ ] 实现简版 Python [ ] Python 虚拟机 [ ] Python 编译结果 [ ] Python 虚拟机框架 [ ] 虚拟机一般表达式 [ ] Python 虚拟机控制流 [ ] Python 虚拟机函数机制 [ ] Python 运行环境初始化 [ ] Python 模块加载机制 [ ] Python 多线程机制 [ ] Python 内存管理机制 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-05-24 09:20:13 "},"preface/code-organization.html":{"url":"preface/code-organization.html","title":"Python 源代码的组织","keywords":"","body":"Python 源代码的组织 源代码下载 方式 1：GitHub Python 源代码可以在 GitHub 上方便的获取，执行： git clone https://github.com/python/cpython.git git checkout v3.7.0 即可获取 Python 3.7.0 版本的代码。 方式 2：Python 官方网站 访问 https://www.python.org/downloads/release/python-370/ ，下拉至页面最下方，可选择下载 tarball 源码包。 亦可执行： wget https://www.python.org/ftp/python/3.7.0/Python-3.7.0.tar.xz 即可获取 Python 3.7.0 版本的代码。 目录结构 进入源码目录，我们可以看到该目录下主要 包含以下文件（夹）： . ├── Doc ├── Grammar ├── Include ├── LICENSE ├── Lib ├── Mac ├── Makefile.pre.in ├── Misc ├── Modules ├── Objects ├── PC ├── PCbuild ├── Parser ├── Programs ├── Python ├── README.rst ├── Tools ├── aclocal.m4 ├── config.guess ├── config.sub ├── configure ├── configure.ac ├── install-sh ├── m4 ├── pyconfig.h.in └── setup.py 其中： Include 目录：包含了 Python 提供的所有头文件，如果用户需要自己用 C 或 C++来编写自定义模块扩展 Python，那么就需要用到这里提供的头文件。 Lib 目录：包含了 Python 自带的所有标准库，且都是用 Python 语言编写的。 Modules 目录：包含了所有用 C 语言编写的模块，比如 math、hashlib 等。它们都是那些对速度要求非常严格的模块。而相比而言，Lib 目录下则是存放一些对速度没有太严格要求的模块，比如 os。 Parser 目录：包含了 Python 解释器中的 Scanner 和 Parser 部分，即对 Python 源代码进行词法分析和语法分析的部分。除此以外，此目录还包含了一些有用的工具，这些工具能够根据 Python 语言的语法自动生成 Python 语言的词法和语法分析器，与 YACC 非常类似。 Objects 目录：包含了所有 Python 的内建对象，包括整数、list、dict 等。同时，该目录还包括了 Python 在运行时需要的所有的内部使用对象的实现。 Python 目录：包含了 Python 解释器中的 Compiler 和执行引擎部分，是 Python 运行的核心所在。 PCbuild 目录：包含了 Visual Studio 2003 的工程文件，研究 Python 源代码就从这里开始（本书将采用 Visual Studio 2017 对 Python 进行编译）。 Programs 目录：包含了 Python 二进制可执行文件的源码。 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-05-24 09:20:13 "},"preface/windows-build.html":{"url":"preface/windows-build.html","title":"Windows 环境下编译 Python","keywords":"","body":"Windows 环境下编译 Python 在 Windows 环境下编译 Python 可完全通过界面操作，主要分为两个步骤： 环境准备 编译 环境准备 在 Python 3.6 及之后的版本可以使用微软的 Visual Studio 2017 进行编译，选择社区版就足够了。 在下载完成后，需要注意安装环节的选项。由于 Python 3.7 所使用的 Windows SDK 的版本为 10.0.17134.0， 所以需要选择安装该 SDK，如下图所示： 编译 进入 Python 源码根目录，打开 PCbuild\\pcbiuld.sln 解决方案，而后进行一些设置： 在左侧的解决方案目录的顶端，右键选择“属性”，以打开属性界面（如下图所示）。 由于我们只是研究 Python 的核心部分，可以选择不编译标准库和外部依赖，在“配置属性”->“配置”中仅勾选 python 和 pythoncore，然后点击“确定”（如下图所示）。 此外，默认情况下的编译设置是 Debug、32 位，您也可以根据自己的需求调整成 Release 或 64 位。 在左侧的解决方案目录中选择 python，右键选择“生成”，以进行编译： 编译结束后，生成的文件存放在PCbuild\\win32目录下（如下图所示），打开python_d即可打开新生成的 Python 3.7 解释器。 更多内容 更多关于在 Windows 上进行编译和开发 Python 的内容见官方指南 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-05-24 09:20:13 "},"preface/unix-linux-build.html":{"url":"preface/unix-linux-build.html","title":"UNIX/Linux 环境下编译 Python","keywords":"","body":"UNIX/Linux 环境下编译 Python 在 UNIX/Linux 环境下编译 Python 较为简单，主要分为两个步骤： 环境准备（准备 Python 所依赖的必要环境） 编译、安装 环境准备 常规操作系统中 编译 Python 前通常需要在系统上安装以下库： gcc // 编译工具 zlib // 压缩、解压相关库 libffi // Python 所以来的用于支持 C 扩展的库 openssl // 安全套接字层密码库，Linux 中通常已具备 不同的发行版，安装方式和包名称也不尽相同。 对于 Debian/Ubuntu，执行： sudo apt install -y zlib1g zlib1g-dev libffi-dev openssl libssl-dev 对于 RedHat/CentOS/Fedora，执行： yum install -y zlib zlib-devel libffi-devel openssl openssl-devel 对于 macOS，执行： xcode-select --install 运行于 Docker 的操作系统中 Docker 版的 Linux 发行版可能会有较多的库未安装，除了安装上一小节提及的库外，其他缺失库可根据情况自行安装： bzip2 // 压缩库 readline // GNU Readline 是一个软件库，它为使用命令行界面（如 Bash）的交互式程序提供了行编辑和历史功能 sqlite // 由 C 编写的小型数据库 libuuid // 跨平台的开源的 uuid 操作库 gdbm // 小型的数据库系统 xz // 压缩解压工具 tk-devel // 图形用户界面开发工具 对于 Debian/Ubuntu，执行： sudo apt-get install bzip2 libbz2-dev sqlite3 libsqlite3-dev libreadline6 libreadline6-dev libgdbm-dev uuid-dev tk-dev 对于 RedHat/CentOS/Fedora，执行： yum install bzip2 bzip2-devel readline-devel sqlite-devel libuuid-devel gdbm-devel xz-devel tk-devel 编译、安装 进入 Python 源码根目录，执行以下命令： ./configure make make install Python 将会被编译，并安装在默认目录中。若您希望将 Python 安装在特定目录，则需要在一开始修改 configure 命令为： ./configure --prefix= 在指定目录中: bin 目录 存放的是可执行文件 include 目录 存放的是 Python 源码的头文件 lib 目录 存放的是 Python 标准库 lib/python3.7/config-3.7m-{platform} 目录 存放的是 libpython3.7m.a，该静态库用于使用 C 语言进行扩展。{platform} 代表平台，比如在 Mac OS 上为 “darwin”，在 Linux 上为 “x86_64-linux-gnu” share 目录 存放的是帮助等文件 默认情况下，编译的 Python 是静态链接（libpython3.7m.a）。如果希望编译的 Python 是动态链接（libpython3.7m.so），则需要在一开始修改configure 命令为： ./configure --enable-shared 如需重新编译，请首先执行： make clean 再执行本节开头处的命令即可。 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-05-24 09:20:13 "},"preface/modify-code.html":{"url":"preface/modify-code.html","title":"修改 Python 源码","keywords":"","body":"修改 Python 源码 在源代码中 Print 在接下来研究源码的过程中，我们可能会对某些语句的逻辑感到好奇，需要输出中间结果。 这就需要借助 Python C API 中打印对象的接口： 源文件：Objects/object.c int PyObject_Print(PyObject *op, FILE *fp, int flags) 比如，我们希望在解释器交互界面中打印整数值的时候输出一段字符串，则我们可以修改如下函数： 源文件：Objects/longobject.c static PyObject * long_to_decimal_string(PyObject *aa) { PyObject *str = PyUnicode_FromString(\"I am always before int\"); PyObject_Print(str, stdout, 0); printf(\"\\n\"); PyObject *v; if (long_to_decimal_string_internal(aa, &v, NULL, NULL, NULL) == -1) return NULL; return v; } 函数实现中的前 3 行为我们加入的代码，其中： PyUnicode_FromString 用于把 C 中的原生字符数组转换为出 Python 中的字符串（Unicode）对象 PyObject_Print 则将转换好的字符串对象打印至我们指定的标准输出（stdout） 对 Python 重新进行编译，在 Unix 上可执行： make && make bininstall 运行编译后的 Python，输入 print 语句即可看到我们希望的结果： >>> print(1) 'I am always before int' 1 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-05-24 09:20:13 "},"objects/object.html":{"url":"objects/object.html","title":"Python 对象初探","keywords":"","body":"Python 对象初探 在Python的世界一切皆对象，不论是整数，还是字符串，甚至连类型、函数等都是一种对象。 对象的分类 以下是Python对象的大致的一个分类 Fundamental 对象: 类型对象 Numeric 对象: 数值对象 Sequence 对象: 容纳其他对象的序列集合对象 Mapping 对象: 类似 C++中的 map 的关联对象 Internal 对象: Python 虚拟机在运行时内部使用的对象 对象机制的基石 PyObject 对于初学者来说这么多类型的对象怎么学？别着急，我们后续章节会解答。 在开始我们的学习之旅之前，我们要先认识一个结构体PyObject，可以说Python的对象机制就是基于PyObject拓展开来的，所以我们先看看PyObject 到底长什么样。 源文件：Include/object.h // Include/object.h #define _PyObject_HEAD_EXTRA \\ struct _object *_ob_next; \\ struct _object *_ob_prev; typedef struct _object { _PyObject_HEAD_EXTRA // 双向链表 垃圾回收 需要用到 Py_ssize_t ob_refcnt; // 引用计数 struct _typeobject *ob_type; // 指向类型对象的指针，决定了对象的类型 } PyObject; Python中的所有对象都拥有一些相同的内容，而这些内容就定义在PyObject中， PyObject 包含 一个用于垃圾回收的双向链表，一个引用计数变量 ob_refcnt 和 一个类型对象指针ob_type 定长对象与变长对象 Python对象除了前面提到的那种分类方法外，还可以分为定长对象和变长对象这两种形式。 变长对象都拥有一个相同的内容 PyVarObject，而 PyVarObject也是基于PyObject扩展的。 从代码中可以看出PyVarObject比PyObject多出了一个用于存储元素个数的变量ob_size。 源文件：Include/object.h // Include/object.h typedef struct _object { _PyObject_HEAD_EXTRA Py_ssize_t ob_refcnt; struct _typeobject *ob_type; } PyObject; typedef struct { PyObject ob_base; Py_ssize_t ob_size; /* Number of items in variable part */ } PyVarObject; 类型对象 前面我们提到了PyObject 的 对象类型指针struct _typeobject *ob_type，它指向的类型对象就决定了一个对象是什么类型的。 这是一个非常重要的结构体，它不仅仅决定了一个对象的类型，还包含大量的元信息， 包括创建对象需要分配多少内存，对象都支持哪些操作等等。 接下来我们看一下struct _typeobject代码 在 PyTypeObject 的定义中包含许多信息，主要分类以下几类: 类型名, tp_name, 主要用于 Python 内部调试用 创建该类型对象时分配的空间大小信息，即 tp_basicsize 和 tp_itemsize 与该类型对象相关的操作信息(如 tp_print 这样的函数指针) 一些对象属性 源文件：Include/object.h // Include/object.h typedef struct _typeobject { PyObject_VAR_HEAD const char *tp_name; /* For printing, in format \".\" */ // 类型名 Py_ssize_t tp_basicsize, tp_itemsize; /* For allocation */ // 创建该类型对象分配的内存空间大小 // 一堆方法定义，函数和指针 /* Methods to implement standard operations */ destructor tp_dealloc; printfunc tp_print; getattrfunc tp_getattr; setattrfunc tp_setattr; PyAsyncMethods *tp_as_async; /* formerly known as tp_compare (Python 2) or tp_reserved (Python 3) */ reprfunc tp_repr; /* Method suites for standard classes */ // 标准类方法集 PyNumberMethods *tp_as_number; // 数值对象操作 PySequenceMethods *tp_as_sequence; // 序列对象操作 PyMappingMethods *tp_as_mapping; // 字典对象操作 // 更多标准操作 /* More standard operations (here for binary compatibility) */ hashfunc tp_hash; ternaryfunc tp_call; reprfunc tp_str; getattrofunc tp_getattro; setattrofunc tp_setattro; ...... } PyTypeObject; 类型的类型 在 PyTypeObjet 定义开始有一个宏PyOject_VAR_HEAD，查看源码可知 PyTypeObjet 是一个变长对象 源文件：Include/object.h // Include/object.h #define PyObject_VAR_HEAD PyVarObject ob_base; 对象的类型是由该对象指向的 类型对象 决定的，那么类型对象的类型是由谁决定的呢？ 对于其他对象，可以通过与其关联的类型对象确定其类型，那么通过什么来确定一个对象是类型对象呢？ 答案就是 PyType_Type 源文件：Objects/typeobject.c // Objects/typeobject.c PyTypeObject PyType_Type = { PyVarObject_HEAD_INIT(&PyType_Type, 0) \"type\", /* tp_name */ sizeof(PyHeapTypeObject), /* tp_basicsize */ sizeof(PyMemberDef), /* tp_itemsize */ ...... }; PyType_Type 在类型机制中至关重要，所有用户自定义 class 所 对应的 PyTypeObject 对象都是通过 PyType_Type创建的 接下来我们看 PyLong_Type 是怎么与 PyType_Type 建立联系的。 前面提到，在Python中，每一个对象都将自己的引用计数、类型信息保存在开始的部分中。 为了方便对这部分内存初始化，Python中提供了几个有用的宏: 源文件：Include/object.h // Include/object.h #ifdef Py_TRACE_REFS #define _PyObject_EXTRA_INIT 0, 0, #else #define _PyObject_EXTRA_INIT #endif #define PyObject_HEAD_INIT(type) \\ { _PyObject_EXTRA_INIT \\ 1, type }, 这些宏在各种内建类型对象的初始化中被大量使用。 以PyLong_Type为例，可以清晰的看到一般的类型对象和PyType_Type之间的关系 源文件：Objects/longobject.c // Objects/longobject.c PyTypeObject PyLong_Type = { PyVarObject_HEAD_INIT(&PyType_Type, 0) \"int\", /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ ...... }; 下图是对象运行时的图像表现 对象的创建 Python创建对象有两种方式 范型API 或称为 AOL (Abstract Object Layer) 这类API通常形如PyObject_XXX这样的形式。可以应用在任何Python对象上， 如PyObject_New。创建一个整数对象的方式 PyObject* longobj = PyObject_New(Pyobject, &PyLong_Type); 与类型相关的API 或称为 COL (Concrete Object Layer) 这类API 通常只能作用于某一种类型的对象上，对于每一种内建对象 Python都提供了这样一组API。例如整数对象，我们可以利用如下的API创建 PyObject *longObj = PyLong_FromLong(10); 对象的行为 在 PyTypeObject 中定义了大量的函数指针。这些函数指针可以视为类型对象中 所定义的操作，这些操作直接决定着一个对象在运行时所表现出的行为，比如 PyTypeObject 中的 tp_hash 指明了该类型对象如何生成其hash值。 在PyTypeObject的代码中，我们还可以看到非常重要的三组操作族 PyNumberMethods *tp_as_number PySequenceMethods *tp_as_sequence PyMappingMethods *tp_as_mapping PyNumberMethods 的代码如下 源文件：Include/object.h // Include/object.h typedef PyObject * (*binaryfunc)(PyObject *, PyObject *); typedef struct { binaryfunc nb_matrix_multiply; binaryfunc nb_inplace_matrix_multiply; ...... } PyNumberMethods; PyNumberMethods 定义了一个数值对象该支持的操作。一个数值对象如 整数对象，那么它的类型对象 PyLong_Type中tp_as_number.nb_add 就指定了它进行加法操作时的具体行为。 在以下代码中可以看出PyLong_Type中的tp_as_number项指向的是long_as_number 源文件：Objects/longobject.h // Objects/longobject.c static PyNumberMethods long_as_number = { (binaryfunc)long_add, /*nb_add*/ (binaryfunc)long_sub, /*nb_subtract*/ (binaryfunc)long_mul, /*nb_multiply*/ ...... }; PyTypeObject PyLong_Type = { PyVarObject_HEAD_INIT(&PyType_Type, 0) \"int\", /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ long_dealloc, /* tp_dealloc */ 0, /* tp_print */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_reserved */ long_to_decimal_string, /* tp_repr */ &long_as_number, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ ...... }; PySequenceMethods *tp_as_sequence 和 PyMappingMethods *tp_as_mapping的分析与PyNumberMethods *tp_as_number 相同，大家可以自行查阅源码 对象的多态性 Python创建一个对象比如 PyLongObject 时，会分配内存进行初始化，然后 Python内部会用 PyObject* 变量来维护这个对象，其他对象也与此类似 所以在 Python 内部各个函数之间传递的都是一种范型指针 PyObject* 我们不知道这个指针所指的对象是什么类型，只能通过所指对象的 ob_type 域 动态进行判断，而Python正是通过 ob_type 实现了多态机制 考虑以下的 calc_hash 函数 Py_hash_t calc_hash(PyObject* object) { Py_hash_t hash = object->ob_type->tp_hash(object); return hash; } 如果传递给 calc_hash 函数的指针是一个 PyLongObject*，那么它会调用 PyLongObject 对象对应的类型对象中定义的 hash操作tp_hash，tp_hash可以在PyTypeObject中找到， 而具体赋值绑定我们可以在 PyLong_Type 初始化代码中看到绑定的是long_hash函数 源文件：Objects/longobject.c // Objects/longobject.c PyTypeObject PyLong_Type = { PyVarObject_HEAD_INIT(&PyType_Type, 0) \"int\", /* tp_name */ ... (hashfunc)long_hash, /* tp_hash */ ... }; 如果指针是一个 PyUnicodeObject*，那么就会调用 PyUnicodeObject 对象对应的类型对象中定义的hash操作，查看源码可以看到 实际绑定的是 unicode_hash函数 源文件：Objects/unicodeobject.c // Objects/unicodeobject.c PyTypeObject PyUnicode_Type = { PyVarObject_HEAD_INIT(&PyType_Type, 0) \"str\", /* tp_name */ ... (hashfunc) unicode_hash, /* tp_hash*/ ... }; 引用计数 Python 通过引用计数来管理维护对象在内存中的存在与否 Python 中的每个东西都是一个对象， 都有ob_refcnt 变量，这个变量维护对象的引用计数，从而最终决定该对象的创建与销毁 在Python中，主要通过 Py_INCREF(op)与Py_DECREF(op) 这两个宏 来增加和减少对一个对象的引用计数。当一个对象的引用计数减少到0之后， Py_DECREF将调用该对象的tp_dealloc来释放对象所占用的内存和系统资源； 但这并不意味着最终一定会调用 free 释放内存空间。因为频繁的申请、释放内存会大大降低Python的执行效率。因此Python中大量采用了内存对象池的技术，使得对象释放的空间归还给内存池而不是直接free，后续使用可先从对象池中获取 源文件：Include/object.h // Include/object.h #define _Py_NewReference(op) ( \\ _Py_INC_TPALLOCS(op) _Py_COUNT_ALLOCS_COMMA \\ _Py_INC_REFTOTAL _Py_REF_DEBUG_COMMA \\ Py_REFCNT(op) = 1) #define Py_INCREF(op) ( \\ _Py_INC_REFTOTAL _Py_REF_DEBUG_COMMA \\ ((PyObject *)(op))->ob_refcnt++) #define Py_DECREF(op) \\ do { \\ PyObject *_py_decref_tmp = (PyObject *)(op); \\ if (_Py_DEC_REFTOTAL _Py_REF_DEBUG_COMMA \\ --(_py_decref_tmp)->ob_refcnt != 0) \\ _Py_CHECK_REFCNT(_py_decref_tmp) \\ else \\ _Py_Dealloc(_py_decref_tmp); \\ } while (0) Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-05-24 09:20:13 "},"objects/long-object.html":{"url":"objects/long-object.html","title":"Python 整数对象","keywords":"","body":"Python 整数对象 CPython2 的整数对象 有 PyIntObject 和 PyLongObject 这两种类型， CPython3 只保留了 PyLongObject 在 源文件：Objects/longobject.c 的第三行有这么一句话 XXX The functional organization of this file is terrible 可见这个变化不是一蹴而就的，有比较艰辛的过程，大家有兴趣可以去挖掘一下 PyLongObject 源文件：Include/longobject.h // longobject.h typedef struct _longobject PyLongObject; /* Revealed in longintrepr.h */ 源文件：Include/longintrepr.h // longintrepr.h /* Long integer representation. The absolute value of a number is equal to 一个数的绝对值等价于下面的表达式 SUM(for i=0 through abs(ob_size)-1) ob_digit[i] * 2**(SHIFT*i) Negative numbers are represented with ob_size 从源码可以看出 PyLongObject 是变长对象 类型对象 PyLong_Type 源文件：Objects/longobject.c // Objects/longobject.c PyTypeObject PyLong_Type = { PyVarObject_HEAD_INIT(&PyType_Type, 0) \"int\", /* tp_name */ offsetof(PyLongObject, ob_digit), /* tp_basicsize */ sizeof(digit), /* tp_itemsize */ long_dealloc, /* tp_dealloc */ 0, /* tp_print */ 0, /* tp_getattr */ 0, /* tp_setattr */ 0, /* tp_reserved */ long_to_decimal_string, /* tp_repr */ &long_as_number, /* tp_as_number */ 0, /* tp_as_sequence */ 0, /* tp_as_mapping */ (hashfunc)long_hash, /* tp_hash */ 0, /* tp_call */ long_to_decimal_string, /* tp_str */ PyObject_GenericGetAttr, /* tp_getattro */ 0, /* tp_setattro */ 0, /* tp_as_buffer */ Py_TPFLAGS_DEFAULT | Py_TPFLAGS_BASETYPE | Py_TPFLAGS_LONG_SUBCLASS, /* tp_flags */ long_doc, /* tp_doc */ 0, /* tp_traverse */ 0, /* tp_clear */ long_richcompare, /* tp_richcompare */ 0, /* tp_weaklistoffset */ 0, /* tp_iter */ 0, /* tp_iternext */ long_methods, /* tp_methods */ 0, /* tp_members */ long_getset, /* tp_getset */ 0, /* tp_base */ 0, /* tp_dict */ 0, /* tp_descr_get */ 0, /* tp_descr_set */ 0, /* tp_dictoffset */ 0, /* tp_init */ 0, /* tp_alloc */ long_new, /* tp_new */ PyObject_Del, /* tp_free */ }; 小整数对象 一些整数在一开始就会被初始化一直留存，当再次使用直接从小整数对象池中获取，不用频繁的申请内存。 默认的小整数范围是 [-5, 257) 源文件：Objects/longobject.c // Objects/longobject.c #ifndef NSMALLPOSINTS #define NSMALLPOSINTS 257 #endif #ifndef NSMALLNEGINTS #define NSMALLNEGINTS 5 #endif #if NSMALLNEGINTS + NSMALLPOSINTS > 0 /* Small integers are preallocated in this array so that they can be shared. The integers that are preallocated are those in the range -NSMALLNEGINTS (inclusive) to NSMALLPOSINTS (not inclusive). */ static PyLongObject small_ints[NSMALLNEGINTS + NSMALLPOSINTS]; #ifdef COUNT_ALLOCS Py_ssize_t quick_int_allocs, quick_neg_int_allocs; #endif static PyObject * get_small_int(sdigit ival) { PyObject *v; assert(-NSMALLNEGINTS = 0) quick_int_allocs++; else quick_neg_int_allocs++; #endif return v; } #define CHECK_SMALL_INT(ival) \\ do if (-NSMALLNEGINTS 宏 CHECK_SMALL_INT 会检查传入的数是否在小整数范围内，如果是直接返回。 可以在创建或复制整数对象等函数中找到 CHECK_SMALL_INT 的身影，以下只列出了 PyLong_FromLong，就不一一列举了 源文件：Objects/longobject.c // Object/longobject.c PyObject * PyLong_FromLong(long ival) { PyLongObject *v; unsigned long abs_ival; unsigned long t; /* unsigned so >> doesn't propagate sign bit */ int ndigits = 0; int sign; CHECK_SMALL_INT(ival); ... } 小整数初始化 源文件：Objects/longobject.c // Objects/longobject.c int _PyLong_Init(void) { #if NSMALLNEGINTS + NSMALLPOSINTS > 0 int ival, size; PyLongObject *v = small_ints; for (ival = -NSMALLNEGINTS; ival ob_digit[0] == (digit)abs(ival)); } else { (void)PyObject_INIT(v, &PyLong_Type); } Py_SIZE(v) = size; v->ob_digit[0] = (digit)abs(ival); } #endif _PyLong_Zero = PyLong_FromLong(0); if (_PyLong_Zero == NULL) return 0; _PyLong_One = PyLong_FromLong(1); if (_PyLong_One == NULL) return 0; /* initialize int_info */ if (Int_InfoType.tp_name == NULL) { if (PyStructSequence_InitType2(&Int_InfoType, &int_info_desc) 整数的存储结构 源文件：Objects/longobject.c 在 long_to_decimal_string_internal中添加如下代码并重新编译安装 // Objects/longobject.c static int long_to_decimal_string_internal(PyObject *aa, PyObject **p_output, _PyUnicodeWriter *writer, _PyBytesWriter *bytes_writer, char **bytes_str) { PyLongObject *scratch, *a; PyObject *str = NULL; Py_ssize_t size, strlen, size_a, i, j; digit *pout, *pin, rem, tenpow; int negative; int d; enum PyUnicode_Kind kind; a = (PyLongObject *)aa; // 添加打印代码 printf(\"ob_size = %d\\n\", Py_SIZE(a)); for (int index = 0; index ob_digit[index]); } ... } 编译安装后进入python解释器输入如下代码 num = 9223372043297226753 print(num) # output >>> ob_size = 3 >>> ob_digit[0] = 1 >>> ob_digit[1] = 6 >>> ob_digit[2] = 8 >>> 9223372043297226753 如下图所示 注：这里的 30 是由 PyLong_SHIFT 决定的，64位系统中，PyLong_SHIFT 为30，否则 PyLong_SHIFT 为15 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-05-24 09:20:13 "},"objects/string-object.html":{"url":"objects/string-object.html","title":"Python 字符串 对象","keywords":"","body":"Python 字符串 对象 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-05-24 09:20:13 "},"objects/list-object.html":{"url":"objects/list-object.html","title":"Python List 对象","keywords":"","body":"Python List 对象 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-05-24 09:20:13 "},"objects/dict-object.html":{"url":"objects/dict-object.html","title":"Python Dict 对象","keywords":"","body":"python字典 Dictionary object implementation using a hash table ，通过描述可知，python的字典就是实现了一个hash表。 Python字典概述 在python的字典中，一个键值对的对应保存就是PyDictEntry类型来保存； typedef struct { /* Cached hash code of me_key. */ Py_hash_t me_hash; PyObject *me_key; PyObject *me_value; /* This field is only meaningful for combined tables */ } PyDictKeyEntry; 其中，me_hash就是哈希生成的值，me_key就是对应的key值，me_value就是对应的值。 在python中，在一个PyDictObject对象的变化过程中，entry的状态会在不同的状态间转换。基本上在如下四种状态中转换：Unused、Active、Dummy和Pending。 Unused:没有插入任何一个获取的key与value，并且在次之前也没有存储任何的key,value，每一个entry在初始化的时候都会处于这种状态，并且Unused会被里面切换到Active态，当有key插入，这是就是entry初始化的状态。 Active:当index>=0时，me_key不为空并且me_value不为空，保存了一个键值对，Active可以转变为Dummy或者Pending状态，当一个健被删除的时候，这只会在me_value不为空的时候出现。 Dummy:先前保存了一个Active的键值对，但是这个键值对被删除了并且一个活跃的键值对还没有填入该位置，Dummy可以转变为Active当删除的时候，Dummy的位置不能被重新使用，一旦发生碰撞，探针序列就无法知道这对键值对曾是活跃的键值对。 Pending:索引>=0，键！=空，值=空（仅拆分），尚未插入到拆分表中。 字典的两种类型 python的字典类型中包含了两种联合字典（split-table dictionaries)与分离字典(combined-table dictonaries)。详细的信息可查看有关dict的描述pep-0412。 split-table dictionaries 当被创建的字典是用来保存object的__dict__属性时，该字典才会创建为一个split-table，它们的健表都被缓存在类型属性中，并且允许所有该类型的实例都可以共享该keys。当出现一个事件讲字典的属性值进行改变的时候，个别字典讲慢慢的转化成组合表的形式。这就保证了在大部分的应用场景下很高的内存利用效率，并保证了在各个场景下的正确性。当split-dict重新改变大小，它会立马改变为一个combined-table，如果重置大小作为保存实例属性的结果，并且只有一个该object的实例，字典会立马再变为一个split-table。如果从split-table中删除一个key, value，它不会删除keys tables中对应的该值，而只是将values数值中移除了该value。 combined-table dictionaries 直接通过dict內建函数与{}生成的字典，模块和大部分其他字典都会创建为combined-table字典，一个combined-table不会改变为一个split-table字典，该字典的行为方式与最初的字典的行为方式大致相同。 容器的相关数据结构 字典对象是通过PyDictObject来实现数据的，详情如下； typedef struct _dictkeysobject PyDictKeysObject; /* The ma_values pointer is NULL for a combined table * or points to an array of PyObject* for a split table */ typedef struct { PyObject_HEAD /* Number of items in the dictionary */ Py_ssize_t ma_used;　 // 使用的ｋｅｙｓ个数 /* Dictionary version: globally unique, value change each time the dictionary is modified */ uint64_t ma_version_tag; PyDictKeysObject *ma_keys;　　　　　// 如果有则是保存的keys数据 /* If ma_values is NULL, the table is \"combined\": keys and values are stored in ma_keys. If ma_values is not NULL, the table is splitted: keys are stored in ma_keys and values are stored in ma_values */ PyObject **ma_values;　 // 如果不为空则保存的是values } PyDictObject; 其中，PyDictKeysObject的定义如下； /* See dictobject.c for actual layout of DictKeysObject */ struct _dictkeysobject { Py_ssize_t dk_refcnt;　　　　　　　　　　　　　　　　　　// 引用计数 /* Size of the hash table (dk_indices). It must be a power of 2. */ Py_ssize_t dk_size;　　　　　　　　　　　　　　　　　　　// hash table 的大小必须是２的倍数 /* Function to lookup in the hash table (dk_indices): - lookdict(): general-purpose, and may return DKIX_ERROR if (and only if) a comparison raises an exception. - lookdict_unicode(): specialized to Unicode string keys, comparison of which can never raise an exception; that function can never return DKIX_ERROR. - lookdict_unicode_nodummy(): similar to lookdict_unicode() but further specialized for Unicode string keys that cannot be the value. - lookdict_split(): Version of lookdict() for split tables. */ dict_lookup_func dk_lookup; // 哈希查找函数 /* Number of usable entries in dk_entries. */ Py_ssize_t dk_usable; // 可用的entry数量 /* Number of used entries in dk_entries. */　 Py_ssize_t dk_nentries;　　　　　　　　　 // 已经使用的entry数量 /* Actual hash table of dk_size entries. It holds indices in dk_entries, or DKIX_EMPTY(-1) or DKIX_DUMMY(-2). Indices must be: 0 相关数据结构的内存布局为； 　Python字典示例 本次示例脚本如下： d = {} d['1']='2' d['1']='e' d.pop('1') 通过Python的反汇编工具获取字节码； python -m dis dict_test.py 输出的字节码如下； 2 0 BUILD_MAP 0 2 STORE_NAME 0 (d) 3 4 LOAD_CONST 0 ('2') 6 LOAD_NAME 0 (d) 8 LOAD_CONST 1 ('1') 10 STORE_SUBSCR 4 12 LOAD_CONST 2 ('e') 14 LOAD_NAME 0 (d) 16 LOAD_CONST 1 ('1') 18 STORE_SUBSCR 5 20 LOAD_NAME 0 (d) 22 LOAD_METHOD 1 (pop) 24 LOAD_CONST 1 ('1') 26 CALL_METHOD 1 28 POP_TOP 30 LOAD_CONST 3 (None) 32 RETURN_VALUE 通过字节码指令可知，首先调用了BUILD_MAP来创建一个新的字典，接着就对新建的字典d进行了赋值操作与更新操作，最后调用了pop方法删除一个key。接下来就详细分析一下相关流程。 字典的初始化流程 通过查找BUILD_MAP的虚拟机执行函数； TARGET(BUILD_MAP) { Py_ssize_t i; PyObject *map = _PyDict_NewPresized((Py_ssize_t)oparg); // 新建并初始化一个字典 if (map == NULL) goto error;　 // 如果新建失败则报错 for (i = oparg; i > 0; i--) {　 　// 检查在新建的过程中是否通过参数传值 int err; PyObject *key = PEEK(2*i); PyObject *value = PEEK(2*i - 1); err = PyDict_SetItem(map, key, value);　　 　　　// 找到对应的值并讲该值设置到map中 if (err != 0) {　　　　　　　　　　　　　　　　　　　　　　　　// 检查是否报错 Py_DECREF(map); goto error;　　　　　　　　　　　　　　　　　　　　　　　　// 如果错误就报错处理 } } while (oparg--) { Py_DECREF(POP());　　　　　　　　　　　　　　　　　　　　　　　// 弹出栈上输入参数的引用 Py_DECREF(POP()); } PUSH(map);　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　// 讲生成的map压栈 DISPATCH();　　　　　　　　　　　　　　　　　　　　　　　　　　　　　// 检查是否需要执行下一条字节码指令 } 从该函数的执行可知，初始化的函数是从_PyDict_NewPresized开始，该函数就是生成并初始化一个字典； PyObject * _PyDict_NewPresized(Py_ssize_t minused) { const Py_ssize_t max_presize = 128 * 1024;　 // 字典最大的容量 Py_ssize_t newsize; PyDictKeysObject *new_keys; /* There are no strict guarantee that returned dict can contain minused * items without resize. So we create medium size dict instead of very * large dict or MemoryError. */ if (minused > USABLE_FRACTION(max_presize)) { // 检查传入的数量是否超过最大值 newsize = max_presize; } else { Py_ssize_t minsize = ESTIMATE_SIZE(minused); // 获取最小的值,在新建一个空的字典的时候该值为０ newsize = PyDict_MINSIZE; // 设置字典的最小值　为８ while (newsize 首先，先计算出需要生成的字典的大小，然后再初始化一个PyDictKeysObject，最后就生成一个PyDictObject返回。继续查看new_keys_object的执行流程； static PyDictKeysObject *new_keys_object(Py_ssize_t size) { PyDictKeysObject *dk; Py_ssize_t es, usable; assert(size >= PyDict_MINSIZE); // 检查size是否大于最小size assert(IS_POWER_OF_2(size)); // 检查是否是２的倍数 usable = USABLE_FRACTION(size); // 检查是否可用　　根据经验在１/2和２/3之间效果最好 if (size 4 else if (size 0) {　　　　　　// 是否有缓存，如果有缓存就选择缓存中的dk dk = keys_free_list[--numfreekeys]; } else { dk = PyObject_MALLOC(sizeof(PyDictKeysObject) + es * size + sizeof(PyDictKeyEntry) * usable); // 没有缓存可使用的字典则申请内存生成一个 if (dk == NULL) { PyErr_NoMemory(); return NULL; } } DK_DEBUG_INCREF dk->dk_refcnt = 1; // 设置引用计数 dk->dk_size = size; // 设置大小 dk->dk_usable = usable; // 设置是否可用 dk->dk_lookup = lookdict_unicode_nodummy; // 设置查找函数 dk->dk_nentries = 0; memset(&dk->dk_indices[0], 0xff, es * size); // 将申请的内存置空 memset(DK_ENTRIES(dk), 0, sizeof(PyDictKeyEntry) * usable); return dk; } 主要就是通过传入的size，检查是否超过设置的大小，检查是否有缓存的字典数据可用，如果没有则申请内存重新生成一个dk，最后进行申请到的内存讲内容清空。接着就会进行new_dict初始化数据； /* Consumes a reference to the keys object */ static PyObject * new_dict(PyDictKeysObject *keys, PyObject **values) { PyDictObject *mp; assert(keys != NULL); if (numfree) {　　　　　　　　　　　　　　　　　　　　　　　　　　　　// 判断缓冲池是否有 mp = free_list[--numfree]; assert (mp != NULL); assert (Py_TYPE(mp) == &PyDict_Type);　 _Py_NewReference((PyObject *)mp);　　　　　　　　　　　　　　// 使用缓冲池对象　　　　 } else { mp = PyObject_GC_New(PyDictObject, &PyDict_Type);　　　　// 缓冲池没有则申请新的对象并初始化 if (mp == NULL) { DK_DECREF(keys); free_values(values); return NULL; } } mp->ma_keys = keys; mp->ma_values = values; mp->ma_used = 0;　　　　　　　　　　　　　　　　　　　　　　　　　　　// 设置ma_used为0 mp->ma_version_tag = DICT_NEXT_VERSION(); assert(_PyDict_CheckConsistency(mp)); return (PyObject *)mp; } new_dict就是根据keys，values设置到从缓冲池或者新生成一个dict对象，最后返回。至此，dict的创建工作已经完成。 字典的插入与查找 通过字节码的指令STORE_SUBSCR可知，该命令就是讲'1'作为key, '2'作为value插入到d中，此时查看该执行函数； TARGET(STORE_SUBSCR) { PyObject *sub = TOP(); // 第一个值为key PyObject *container = SECOND(); // 该为字典对象 PyObject *v = THIRD(); // 该为value int err; STACKADJ(-3); /* container[sub] = v */ err = PyObject_SetItem(container, sub, v); // 调用该方法设置值 Py_DECREF(v); Py_DECREF(container); Py_DECREF(sub); if (err != 0) goto error; DISPATCH(); 此时，从栈中取出相关参数，并将这些值传入PyObject_SetItem函数进行处理设置值； int PyObject_SetItem(PyObject *o, PyObject *key, PyObject *value) { PyMappingMethods *m; if (o == NULL || key == NULL || value == NULL) {　　　　　　　　　　　// 检查是否为空如果任一为空则报错 null_error(); return -1; } m = o->ob_type->tp_as_mapping;　　　　　　　　　　　　　　　　　　　　　　// 获取类型的tp_as_mapping方法集　　　　　 if (m && m->mp_ass_subscript)　　　　　　　　　　　　　　　　　　　　　　　// 如果有设置该类型 return m->mp_ass_subscript(o, key, value); // 调用该mp_ass_subscript方法 if (o->ob_type->tp_as_sequence) { // 获取作为队列的操作集 if (PyIndex_Check(key)) {　　　　　　　　　　　　　　　　　　　　　　　// 检查key是否是索引 Py_ssize_t key_value; key_value = PyNumber_AsSsize_t(key, PyExc_IndexError);　 if (key_value == -1 && PyErr_Occurred()) return -1; return PySequence_SetItem(o, key_value, value);　　　　　　　// 调用索引插入 } else if (o->ob_type->tp_as_sequence->sq_ass_item) { type_error(\"sequence index must be \" \"integer, not '%.200s'\", key); return -1; } } type_error(\"'%.200s' object does not support item assignment\", o);　　　// 则该类型对象不支持设置 return -1; } 其中就调用了字典的tp_as_mapping的方法集，并调用了该方法集的mp_ass_subscript方法；此时我们分析一下，dict的tp_as_mapping的方法集。此时就调用了tp_as_mapping的mp_ass_subscript方法，此时就是调用dict的dict_ass_sub方法； static int dict_ass_sub(PyDictObject *mp, PyObject *v, PyObject *w) { if (w == NULL) return PyDict_DelItem((PyObject *)mp, v); else return PyDict_SetItem((PyObject *)mp, v, w); } 可知，删除一个key就是PyDict_DelItem,设置一个key就是PyDict_SetItem； int PyDict_SetItem(PyObject *op, PyObject *key, PyObject *value) { PyDictObject *mp; Py_hash_t hash; if (!PyDict_Check(op)) {　　　　　　　　　　　 // 检查是否是字典类型 PyErr_BadInternalCall(); return -1; } assert(key); assert(value); mp = (PyDictObject *)op; if (!PyUnicode_CheckExact(key) || (hash = ((PyASCIIObject *) key)->hash) == -1)　　// 检查传入的key是否hash为-1 { hash = PyObject_Hash(key); // 生成hash调用key对应的tp_hash方法，在本例中传入的是str类型，则调用str类型的tp_hash方法 if (hash == -1) return -1; } /* insertdict() handles any resizing that might be necessary */ return insertdict(mp, key, hash, value); // 生成hash调用key对应的tp_hash方法 } insertdict方法就是将生成的方法，插入到字典中去； static int insertdict(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject *value) { PyObject *old_value; PyDictKeyEntry *ep; Py_INCREF(key); Py_INCREF(value); if (mp->ma_values != NULL && !PyUnicode_CheckExact(key)) { if (insertion_resize(mp) ma_keys->dk_lookup(mp, key, hash, &old_value);　　　　 // 调用查找方法 if (ix == DKIX_ERROR) goto Fail; assert(PyUnicode_CheckExact(key) || mp->ma_keys->dk_lookup == lookdict); MAINTAIN_TRACKING(mp, key, value); // 检查mp key values是否需要加入垃圾回收 /* When insertion order is different from shared key, we can't share * the key anymore. Convert this instance to combine table. */ if (_PyDict_HasSplitTable(mp) && ((ix >= 0 && old_value == NULL && mp->ma_used != ix) || (ix == DKIX_EMPTY && mp->ma_used != mp->ma_keys->dk_nentries))) {　　// 检查是否是分离表，如果没查找到旧值并且 if (insertion_resize(mp) ma_keys->dk_usable ma_keys, hash);　　　　　　　　　// 查找一个可用的hash位置 ep = &DK_ENTRIES(mp->ma_keys)[mp->ma_keys->dk_nentries];　　　　　　　　　// 获取存取的地址 dk_set_index(mp->ma_keys, hashpos, mp->ma_keys->dk_nentries);　　　　　　// 设置该值 ep->me_key = key;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　// 保存key ep->me_hash = hash; // 保存计算得出的hash值 if (mp->ma_values) {　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　// 如果mp的ma_values有值 assert (mp->ma_values[mp->ma_keys->dk_nentries] == NULL); mp->ma_values[mp->ma_keys->dk_nentries] = value;　　　　　　　　　　　// 设置该key对应的value } else { ep->me_value = value; // 直接讲value设置到entry上面 } mp->ma_used++;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 // 使用个数加１ mp->ma_version_tag = DICT_NEXT_VERSION();　　 mp->ma_keys->dk_usable--;　　　　　　　　　　　　　　　　　　　　　　　　　　　　// 可用减１ mp->ma_keys->dk_nentries++; assert(mp->ma_keys->dk_usable >= 0); assert(_PyDict_CheckConsistency(mp)); return 0; } if (_PyDict_HasSplitTable(mp)) { // 如果是分离的 mp->ma_values[ix] = value; // 直接设置ma_values对应的ix到values中 if (old_value == NULL) { /* pending state */ assert(ix == mp->ma_used); mp->ma_used++;　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　// 使用加１ } } else { assert(old_value != NULL); DK_ENTRIES(mp->ma_keys)[ix].me_value = value; } mp->ma_version_tag = DICT_NEXT_VERSION(); Py_XDECREF(old_value); /* which **CAN** re-enter (see issue #22653) */ assert(_PyDict_CheckConsistency(mp)); Py_DECREF(key); return 0; Fail: Py_DECREF(value); Py_DECREF(key); return -1; } 首先会调用相关的查找方法，去查找待搜索的值是否已经存在字典中，如果当前字典数据已经满了则会按照增长大小的函数生成一个新的字典，并把旧数据设置到新的字典中，当找到的字典匹配时则返回。 其中dk_lookup对应的方法，在初始化之后对应的是lookdict_unicode_nodummy； /* Faster version of lookdict_unicode when it is known that no keys * will be present. */ static Py_ssize_t _Py_HOT_FUNCTION lookdict_unicode_nodummy(PyDictObject *mp, PyObject *key, Py_hash_t hash, PyObject **value_addr) { assert(mp->ma_values == NULL); /* Make sure this function doesn't have to handle non-unicode keys, including subclasses of str; e.g., one reason to subclass unicodes is to override __eq__, and for speed we don't cater to that here. */ if (!PyUnicode_CheckExact(key)) {　　　　　　　　　　　　　　　　　　　　　// 检查如果不是ｕｎicode则直接调用lookdict方法查找 mp->ma_keys->dk_lookup = lookdict; return lookdict(mp, key, hash, value_addr); } PyDictKeyEntry *ep0 = DK_ENTRIES(mp->ma_keys);　　　　　　　　　　　　　// 获取keys的首个元素地址 size_t mask = DK_MASK(mp->ma_keys);　　　　　　　　　　　　　　　　　　　　// 获取大小 size_t perturb = (size_t)hash; size_t i = (size_t)hash & mask;　　　　　　　　　　　　　　　　　　　　　　　// 获取生成的最终的值　　　　　　　　　　　　　　　　　 for (;;) { Py_ssize_t ix = dk_get_index(mp->ma_keys, i); // 便利ma_keys　ｋey列表 assert (ix != DKIX_DUMMY);　　　　　　　　　　　　　　　　　　　　　// 判断不能为空 if (ix == DKIX_EMPTY) { // 如果为空则证明找到一个可以使用的 *value_addr = NULL;　　　　　　　　　　　　　　　　　　　　　　　// 讲key对应的value设置为空 return DKIX_EMPTY;　　　　　　　　　　　　　　　　　　　　　　　 // 返回 } PyDictKeyEntry *ep = &ep0[ix]; 　　　　　　　　　　　　// 获取该位置元素值 assert(ep->me_key != NULL); assert(PyUnicode_CheckExact(ep->me_key)); if (ep->me_key == key || (ep->me_hash == hash && unicode_eq(ep->me_key, key))) {　　// 如果key相同 ｈａｓｈ值也相同 *value_addr = ep->me_value;　　　　　　　　　　　　　　　　　　　 // 将该值赋值 return ix; } perturb >>= PERTURB_SHIFT;　　　　　　　　　　　　　　　　　　　　　　// 偏移 i = mask & (i*5 + perturb + 1);　　　　　　　　　　　　　　　　　　　// 获取下一个位置 } Py_UNREACHABLE(); } 该函数的主要工作就是查找，字典中是否有空余的值，或者如果找到了满足hash值与key相同的就将value设置为找到的值（这也是字典查找的核心逻辑）。至此，字典的插入的大致流程已经分析完毕。 Python字典的操作测试 现在我们动手观看一下具体的操作实例，首先声明，该例子仅供调试使用，目前调试的字典的key与value都是float类型并且不能del或者pop其中的key。操作字典如下所示； ｄ = {20000:2} d[1] = 2 d[3] = 2 首先，讲如下代码插入到dictobject.c的1060行； // 测试代码 PyObject* key1 = PyLong_FromLong(20000); Py_hash_t hash1 = PyObject_Hash(key1); PyObject* old_value1; Py_ssize_t ix1 = mp->ma_keys->dk_lookup(mp, key1, hash1, &old_value1); if (ix1 == 0){ PyLongObject* give; give = (PyLongObject* )key1; printf(\"found value : %ld\\n\", give->ob_digit[0]); PyDictKeyEntry *ep01 = DK_ENTRIES(mp->ma_keys); int i, count; count = mp->ma_used; int size_count, j; size_count = mp->ma_keys->dk_size; printf(\"%s \", mp->ma_keys->dk_indices); int8_t *indices = (int8_t*)(mp->ma_keys->dk_indices); printf(\"indices index values :\"); for (j=0; jme_key; printf(\"size : %d \", mp->ma_keys->dk_size); printf(\"found value while 　key : %ld \", give->ob_digit[0]); give = (PyLongObject* )ep01->me_value; printf(\"value : %ld\\n\", give->ob_digit[0]); ep01++; } } 然后编译运行； Python 3.7.3 (default, May 22 2019, 16:17:57) [GCC 7.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> d = {20000:2} found value : 20000 indices index values :0 -1 -1 -1 -1 -1 -1 -1 size : 8 found value while 　key : 20000 value : 2 其中为什么初始化的时候输入20000，是根据代码找到相关的key值，因为字典也被python自身实现的结构中引用了多次，所以我们就设置了一个特殊值来跟踪我们想要的字典；当d初始化的时候，就输出如上所示内容；我们接下来继续操作； >>> d = {20000:2} found value : 20000 indices index values :0 -1 -1 -1 -1 -1 -1 -1 size : 8 found value while 　key : 20000 value : 2 >>> d[2] = 3 found value : 20000 indices index values :0 -1 1 -1 -1 -1 -1 -1 size : 8 found value while 　key : 20000 value : 2 size : 8 found value while 　key : 2 value : 3 >>> d[3] = 4 found value : 20000 indices index values :0 -1 1 2 -1 -1 -1 -1 size : 8 found value while 　key : 20000 value : 2 size : 8 found value while 　key : 2 value : 3 size : 8 found value while 　key : 3 value : 4 >>> d[5] = 6 found value : 20000 indices index values :0 -1 1 2 -1 3 -1 -1 size : 8 found value while 　key : 20000 value : 2 size : 8 found value while 　key : 2 value : 3 size : 8 found value while 　key : 3 value : 4 size : 8 found value while 　key : 5 value : 6 >>> d[7] = 8 found value : 20000 indices index values :0 -1 1 2 -1 3 -1 4 size : 8 found value while 　key : 20000 value : 2 size : 8 found value while 　key : 2 value : 3 size : 8 found value while 　key : 3 value : 4 size : 8 found value while 　key : 5 value : 6 size : 8 found value while 　key : 7 value : 8 此后我们一直添加值进d，从输出信息可知，index就是记录了PyDictKeyEntry的索引值，-1就表示该处未使用。 当我们继续向d中添加内容时； >>> d[9] = 10 found value : 20000 indices index values :0 -1 1 2 -1 3 -1 4 -1 5 -1 -1 -1 -1 -1 -1 size : 16 found value while 　key : 20000 value : 2 size : 16 found value while 　key : 2 value : 3 size : 16 found value while 　key : 3 value : 4 size : 16 found value while 　key : 5 value : 6 size : 16 found value while 　key : 7 value : 8 size : 16 found value while 　key : 9 value : 10 >>> d[10] = 11 found value : 20000 indices index values :0 -1 1 2 -1 3 -1 4 -1 5 6 -1 -1 -1 -1 -1 size : 16 found value while 　key : 20000 value : 2 size : 16 found value while 　key : 2 value : 3 size : 16 found value while 　key : 3 value : 4 size : 16 found value while 　key : 5 value : 6 size : 16 found value while 　key : 7 value : 8 size : 16 found value while 　key : 9 value : 10 size : 16 found value while 　key : 10 value : 11 从输出内容可知，字典的大小随之改变了，这也说明了python字典的最佳大小容量限定在1/2到2/3之间，如果超过这个阈值则字典就会自动扩容，扩容的策略大家可详细查看源码。 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-05-24 09:20:13 "},"objects/set-object.html":{"url":"objects/set-object.html","title":"Python Set 对象","keywords":"","body":"Python Set 对象 Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-05-24 09:20:13 "},"objects/simple-implementation.html":{"url":"objects/simple-implementation.html","title":"实现简版 Python","keywords":"","body":"实现简版 Python Copyright © Prodesire 2018 all right reserved，powered by Gitbook该文件修订时间： 2019-05-24 09:20:13 "}}